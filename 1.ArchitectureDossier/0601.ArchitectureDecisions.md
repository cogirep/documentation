## AD-001 : Déploiement de conteneurs Docker, opérés au travers d'un orchestrateur

### Décision d'architecture
|Identifiant|Décision d'architecture|Domaine|Date|Comité|
|---|---|---|---|---|
|**AD-001**|Déploiement de conteneurs Docker, opérés au travers d'un orchestrateur|Stratégie d'implémentation des fonctions "métier"|**2018-05-09**|S Cassini, V Robinet , J Morgado, F Fadda, S Wilbert|

### Enjeux
L'évolution des solutions vers un mode d'hébergement "élastique", et permettant des déploiements en continu de fonctions, notamment dans le "Cloud" nécessite de définir la meilleure approche de déploiement de la logique applicative.

Pour une application _"née dans le Cloud"_ -ou **"Cloud Native"**- (à opposer à une application _"Prête pour le cloud"_ -ou **"Cloud Ready"**-), certains critères sont à intégrer dès la conception.


#### Stratégie d'implementation

**Provisionnement automatique :** La solution doit pouvoir être déployée de manière totalement automatisée. Ceci afin de privilégier des temps de mise sur le marché (Time-To-Market) réduits.

**Élasticité :** le mode de déploiement doit permettre d'adapter la capacité automatiquement (Croissance et/ou décroissance) de la solution aux sollicitations de ses usages (utilisateurs et/ou tiers externes).

Dans les cas les plus aboutis, une solution qui n'est pas utilisée (période d'inactivité par exemple) ne nécessite aucune machine en veille. Celle-ci étant provisionnée en quelques secondes à la première sollicitation puis arrêtée après usage. On parle dans ce cas d'approche **"ServerLess"**.

Parfois normalisée, cette approche est souvent implémentée différemment par les fournisseurs de Cloud :

- [Amazon Lambda Function](https://aws.amazon.com/lambda),
- [Apache OpenWhisk sur IBM Cloud](https://console.bluemix.net/openwhisk/),
- [Google Cloud Functions](https://cloud.google.com/functions/?hl=fr),
- [Microsoft Azure Functions](https://azure.microsoft.com/fr-fr/services/functions/).

Afin de limiter l'adhérence aux fournisseurs de Cloud, des librairies d'encapsulation ont été implémentées par exemple le framework 'https://serverless.com'

Celles-ci permettent de limiter le couplage entre le code et le fournisseur Cloud.
Cette limite pouvant être le composant utilisé à l'intérieur des fonctions _Serverless_. A titre d'exemple, pour une fonction AWS Lambda reposant sur une persistance de données dans le composant AWS DynamoDB (composant specifique AWS), le framework d'encapsulation permettre de potentiellement porter le code AWS LAmbda sur un autre fournisseur de cloud, néanmoins il devra etre adapté pour porter les composants spécifiques qui seraient implémentés par la fonction (DynamoDB-> Autre base de données no-sql par exemple)

**Mesure (et facturation) de l'usage**

Cette stratégie d'implémentation revêt un intérêt en termes d'exploitation. En effet, n'étant active qu'après une sollicitation externe (Humaine/Machine), aucune supervision n'est requise quand 'SANS -serveur'


>Remarques :
>- Différents langages de programmation peuvent être implémentés en fonction "ServerLess": NodeJS, Java, C#...
> - Les fonctions "serverless" necessite d'integrer plusieurs contraintes aux implementations:
>    - La mémoire, la puissance de calcul est limité pour une fonction unitaire
>    - L'optimisation du code produit est impérative afin de minimiser le temps d'exécution (et donc souvent la facturation) des fonctions


Un tactique alternative consiste à reposer sur d’autres mécanismes de déploiement: Appoche par '**conteneur (Docker)** supervisé par un orchestrateur permet d’atteindre une bonne élasticité et un provisionnement automatique tout en permettant un meilleur portage


#### Modèles de déploiement

**0 - "On Premises"**
Une approche OnPremises repose sur les machines (privées) du centre de calcul

**1 - Public Cloud / Le cloud ‘Public’**
Un cloud ‘public’ expose ses services au travers d’un réseau accessible publiquement (Internet) :par exemple  IBM Cloud

**2 - Private Cloud / Le cloud ‘Privé’**
Un cloud privé est mis a disposition dans les centres de calcul (« Data Centers ») de son propriétaire/consommateur. Si la catalogue de services exposé est plus restreint que dans le Cloud public, cela permet d’atteindre un fort niveau de sécurité, reposer sur les infrastructures du consommateur… (Architecture reposant sur les conteneurs d’applications/Kubernetes): par exemple  IBM Cloud Private

=> Le **« Virtual Private Cloud »** aussi appelé “dedicated cloud” permet de définir un environnement dédié a son usager (tenant) dans le Cloud Public

**3 - Hybrid Cloud:** C’est la conjonction d’un/’plusieurs’ cloud, avec les les Centres de Calcul du consommateur afin de réaliser un système d’information complet.



### Hypothèses

- Pour les modes de mise en œuvre 'Cloud' seules les approches **Container-As-A-Service (CaaS) et Serverless** sont considérées. Par défaut, les approches IaaS (Infrastructure)/PaaS (Platform)/ SaaS (Software) ne sont pas étudiées afin de présenter un fort découplage entre l'implémentation et l'hébergeur Cloud

- La solution doit pouvoir être proposée :
  - En **SaaS**: Le consommateur (ou "Tenant") utilise un service en ligne (intégré avec ses systèmes d'informations)
  - En mode **"On Premises"** La mise en œuvre doit pouvoir être possible dans un mode hébergé par le consommateur (Pour répondre à certains besoins de confidentialité)

- La conception de la solution doit envisager les changements d'hébergeur (Fournisseur de Service Cloud) en limitant les impacts en termes de réécriture de code

- Les nouvelles versions de la solution doit pouvoir être délivrée avec des cycles courts de développement, et en limitant l'impact aux utilisateurs

### Alternatives


#### Alternative 01 - Mise en oeuvre d'une approche "ServerLess"

Implémentation de fonctions serverless mise en œuvre par un fournisseur de cloud, en intégrant un framework d'encapsulation (par exemple Serverless.com)


**Avantages:**

 - Modele "cloud native"
 - Simplicité

**Inconvénients:**

- Adhérence aux fournisseurs Cloud

| Domaine|Niveau atteint|
|---|:---:|
| Provisionnement automatique |**FORT**|
| Elasticité |**FORT**|
| Mesure /optimisation de l'usage des ressources |**FORT**|
| Généricité ("Vendor Agnostic") |**FAIBLE**|
| Portage de la solution (On prem/Cloud) |**NUL**|
| Cloud Native pattern (vs. autres alternatives) |**FORT**|

>Remarque :
> L'approche consistant à déployer des fonctions "Serverless" en mode 'On-premises' n'est pas étudiée car jugée pas suffisamment mature /Industrielle

#### Alternative 02 - Déploiement de conteneurs Docker, opérés au travers d'un orchestrateur

Implémentation de conteneurs ochestré (Docker Swarm/Kubernetes)

>**Remarque** : Cette approche de déploiement est en cours de prototypage pour l'hyperviseur en mode Kubernetes/Docker


**Avantages:**
 - Maitrise complete (Monitoring, Configuration Debug)
 - Peut etre controlé par des orchestrateurs permettant de gerer le 'Failover', la gestion de charge.

**Inconvénients:**
- Le conteneur reste actif, y compris sans sollicitations externes


| Domaine | Niveau atteint|
|---|:---:|
|Provisionnement automatique |**FORT**|
|Elasticité |**MOYEN**|
|Mesure /optimisation de l'usage des ressources |**MOYEN**|
|Généricité ("Vendor Agnostic") |**FORT**|
|Portage de la solution (On prem/Cloud) |**FORT**|
|Cloud Native  pattern (vs. autres alternatives) |**MOYEN**|


#### Alternative 03 - Approche Hybride (Container/Serverless)

La déqualification de l'alternative par fonctions "ServerLess" invalide cette approche


### Recommandation

**Alternative 02 - Déploiement de conteneurs Docker, opérés au travers d'un orchestrateur**

### Justification

Modèle de déploiement permettant d'atteindre l'ensemble des critères avec un niveau industriel éprouvé.
  - 'Cloud Native'pattern
  - Flexibilité
  - Robustesses
  - Portage vers d'autres providers
  - Compatibilité "On Premises"

### Implications
[Formalisation des exigences dérivant de cette décision d'Architecture]

### Décisions d'architecture liées
|**Identifiant**|**Decision d'architecture**|
|---|---|
|**AD-002**| Kubernetes est l'orchestrateur des conteneurs.|
